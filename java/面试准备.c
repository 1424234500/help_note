

Jvm new对象机制 堆分配 内存回收 
	class加载机制 双亲委派父类识别优先加载，避免根类加载器jdk被串改？ 缓存机制 	

jdk差异 1.8 hashmap实现差别 红黑树 hash地址 数组链表 以对象为键 有什么问题Java排序 哪些比较器 自定义实现
	key过多阈值转换红黑树，对于实现了Comparable 接口的键(对象)，插入或删除的操作会更简单  二分红黑树查找键 而非简单hash查找键


#Java并发线程协作 volatile  锁 sync和 lock 介绍 差别 公平性  抢占资源 wait sleep   threadpool

修改场景：并发
	i++  读取 修改 写入问题
		多线程并发i++可能比预期小 cpu多核多线程脏读写
	我必须是看到数据才决定的更改，若在保存前变了，得在变了的基础上重新修改
1.保证原子性 并发 
#方案： 
	是否需要先比较再修改 
	volatile 是否满足要求
	锁
	
#原子性是否保证可见性？
	原子性不一定保证可见性。比如 CAS 只解决了比较和更新的原子性的问题，要保证可见性，需要加锁或者是用 volatile 修饰变量。 		

2.锁概念 
#乐观锁 基本没人抢 读多写少
	查询 若没变则修改 	写多时会导致总是变化 而导致重新查询后 再次尝试修改 低效
	原子类（CAS Compare And Swap实现） 多线程累加器 

#悲观锁 总会有人抢我的 写多
	加锁 查询 修改  
	for update（锁定查询的行）
	sync
	
4.final 作用 初始化 闭包? 生命周期改变 子线程可见域
5.volatile 并发关键字 不缓存 写时直接写入主存  读时直接读主存  
	有限的一些情形下使用 volatile 变量替代锁（简单 性能）  1.对变量的写操作不依赖于当前值。  2.该变量没有包含在具有其他变量的不变式中。
	可见性 : 对一个 volatile 的变量的读，总是能看到任意线程对这个变量最后的写入.
	原子性 : 对于单个 volatile 变量的读或者写具有原子性，复合操作不具有.(如 i++)
	互斥性 : 同一时刻只允许一个线程对变量进行操作.(互斥锁的特点)
	确保通过排他锁单独获得这个变量
	
	正确使用 volatile 
		模式：状态标志	仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。
		模式：volatile bean  JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。
6.Synchronized 悲观锁 自动释放 不能被继承 尽量减少锁区间范围   简化代码尽量使用
	非公平
	原子性：可重入 下一个CPU时间片还是只能被他自己获取到，直到所有代码执行完
	可见性：对一个 synchronized 修饰的变量解锁之前，必须先把此变量同步回主存中。
	可重入性：获得一次锁之后，如果调用其它同步方法，不需要重新获取锁，可以直接使用。
	不可中断性：一旦这个锁被某线程获得，其他线程只能等待或者阻塞。Lock 锁可以中断或者退出等待（超时机制）。
	
	对于普通同步方法，锁是当前实例 this。
	对于静态同步方法，锁是当前类 XXX.class。
	对于同步方法块，锁是 synchronized 括号里配置的对象。
	
	jse1.6 效率优化 
	锁升级	主要想要避免其他线程阻塞切换cpu上下文
	无锁状态、								多线程循环尝试获取（CAS）
	偏向锁状态、							竞争不大 减少锁操作不释放	单线程？遇到竞争才会释放锁，线程不会主动释放偏向锁		关闭偏向锁：-XX:-UseBiasedLocking=false 默认进入轻量级锁
	轻量级锁状态、							当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能
	重量级锁状态							等待锁的线程都会进入阻塞状态
	随着竞争情况逐渐升级。锁可以升级但不能降级 
 
	锁对象不能为空
	作用域不宜过大
	避免死锁

7.Lock	必须finally手动释放  AbstractQueuedSynchronizer(AQS)	复杂实现 可(超时)判断 分布式锁  
代码级别的并发，需要使用锁实现提供的独特机制，例如：读写分离、分段、中断、共享、重入等 synchronized 不支持的机制。
	问题：多次重入  多次释放
	重入锁（ReentrantLock）	
		公平锁（FairSync）
		非公平锁（NonfairSync）
	读锁（ReadLock） 支持重进入的共享锁  读锁的存在意味着不允许其他写操作的存在
	写锁（WriteLock）支持重进入的排它锁 
	
0死锁
互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

预防死锁：
一次性分配所有资源12（资源编码组合状态）（破坏请求条件）
拿不到资源2就释放已有资源1（破坏请保持条件）
资源12有序分配法 释放则相反（破坏环路等待条件） 


8.ThreadPoolExecutor 
ThreadLocal  数据副本 线程切面耗时
	线程同步问题

	sleep：定时器唤醒	不释放锁
	wait： 需要在同步块里 notify随机唤醒/notifyAll唤醒所有
	park： 需要在同步块里 unpark唤醒指定
	Condition：signal随机唤醒/signalAll
	
	线程池构造 队列选择  队列容量 分工核心数评估
	拒绝策略s
	线程状态

	ExecutorService工厂制造 fixed固定数量 sing单线 sch单线周期(间隔时间or固定时间)
		ThreadPoolExecutor(int corePoolSize,		//核心数
									线程池个数=CPU的数量*CPU的使用率*（1+等待时间/计算时间）
		
                              int maximumPoolSize,	//最大数
                              long keepAliveTime,	//非核心存活时间
                              TimeUnit unit,		//时间单位
                              BlockingQueue<Runnable> workQueue,	//队列实现
									SynchronousQueue  eg:  4, 100 	    直接提交队列：没有容量，每一个插入操作都要等待一个相应的删除操作。通常使用需要将maximumPoolSize的值设置很大，否则很容易触发拒绝策略。
									ArrayBlockingQueue	有界的任务队列 
									LinkedBlockingQueue	无界(可指定容量有界)的任务队列：线程个数最大为corePoolSize，如果任务过多，则不断扩充队列，知道内存资源耗尽。
									PriorityBlockingQueue	优先任务队列：是一个无界的特殊队列，可以控制任务执行的先后顺序，而上边几个都是先进先出的策略。 
									DelayQueue 是 Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部 是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。
                              ThreadFactory threadFactory,			//工厂覆盖
                              RejectedExecutionHandler handler) 	//丢弃模式
									JDK提供的线程池拒绝策略
									策略名称	描述
									AbortPolicy	该策略会直接抛出异常，阻止系统正常 工作。线程池默认为此。
									CallerRunsPolicy	只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。
									DiscardOledestPolicy	该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试重新提交当前任务。
									DiscardPolicy	该策略默默地丢弃无法处理的任务，不予任务处理。
									
									
		添加任务
			优先顺序 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 		


9.Redis 分布式锁 其他实现的锁 缓存穿透击穿雪崩 一致性
	缓存穿透
	缓存没有命中-数据库也没有命中-查询失败-加剧反复查询   数据库反复查询
		缓存空对象 过期时间		存储null占用空间 取舍	一段时间查询和数据库不一致 
		
		并非全局map而低消耗预先知道数据库有没有  
		布隆过滤器（预热初始化key）	预计容量,容错率 -> 容器长度,hash个数 guava 性能!
		
		
	缓存击穿 
	热点数据-突然失效-并发查询数据库

	缓存雪崩
	缓存宕机-大量访问导致数据库宕机
		避免宕机 redis高可用 集群主备 同城双活
		限流降级 熔断模式 成功率过低则限流 逐渐阶梯放开
		数据预热 不同过期时间 避免同时失效
		
	一致性
		先修改缓存，再修改数据库	多线程情况 存在缓存又被写入
		延迟双删 先修改缓存，再修改数据库（重复操作，确保删除成功），再修改缓存	延迟队列
		
		缓存更新还是删除？ 		修改缓存value的成本较高，一般选择直接淘汰缓存。
		
		先更新数据库，再更新缓存
			功能问题：请求A和请求B进行更新操作 后来先更新缓存会导致脏A
			性能问题：读少写多的情况导致浪费，删除可迟加载 
		先更新数据库，再删除缓存 
	　　先删除缓存，再更新数据库
			功能问题：请求A和请求B进行操作 A删缓存 B查出又设置了旧缓存 导致脏旧
				解决方案：延迟双删， 删除缓存，更新数据库之后，延迟一段时间再次删除缓存（若失败? 重试几次报警记录日志=人工介入？）
					mysql主从读写分离：未主从同步时 依然有问题 延时间隔 
	
	
		先更新缓存，再更新数据库？？
			数据库失败会导致脏数据
		
		
		
90.消息队列 #kafka
解耦、异步、削峰

缺点#
系统的可用性降低
系统引入的外部依赖越多，系统越容易挂掉，本来只是A系统调用BCD三个系统接口就好，ABCD四个系统不报错整个系统会正常运行。引入了MQ之后，虽然ABCD系统没出错，但MQ挂了以后，整个系统也会崩溃。
系统的复杂性提高
引入了MQ之后，需要考虑的问题也变得多了，如何保证消息没有重复消费？如何保证消息不丢失？怎么保证消息传递的顺序？
一致性问题
A系统发送完消息直接返回成功，但是BCD系统之中若有系统写库失败，则会产生数据不一致的问题。

把自己消费过的消息的offset提交一下，代表我已经消费过了
幂等性，我通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。
	数据库主键查一下
	写redis，那没问题了，反正每次都是set，天然幂等性
事务机制一搞，基本上吞吐量会下来，因为太耗性能
事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息rabbitmq接收了之后会异步回调你一个接口通知你这个消息接收到了。
所以一般在生产者这块避免数据丢失，都是用confirm机制的。
kafka会自动提交offset，那么只要关闭自动提交offset，在处理完之后自己手动提交offset，就可以保证数据不会丢。但是此时确实还是会重复消费，比如你刚处理完，还没提交offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。
给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition必须有至少2个副本
在kafka服务端设置min.insync.replicas参数：这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系，没掉队，这样才能确保leader挂了还有一个follower吧
在producer端设置acks=all：这个是要求每条数据，必须是写入所有replica之后，才能认为是写成功了
在producer端设置retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了
我们生产环境就是按照上述要求配置的，这样配置之后，至少在kafka broker端就可以保证在leader所在broker发生故障，进行leader切换时，数据不会丢失


	
10.Netty IO NIO react模式 哪些插件	cpu稀疏型
	处理多个连接
	BIO 多线程阻塞等待网络流写入
	场景：
		每次有一个客户端连接进来的时候，都会有一个新的线程去处理，缺点显而易见，如果连接比较多的时候，我们就要建立大量的线程去一一处理
 		Socket socket = ServerSocket.accept();
		来一个长连接，记录句柄到list中，开一个子线程负责死循环监控读取该句柄的写入流	
		不具备弹性伸缩	线程个数和并发访问数成线性正比	性能急剧下降
	NIO 线程阻塞的方式监听 IO 事件	
		IO多路复用	避免由于频繁IO阻塞导致的线程挂起 JDK1.6版本使用epoll替代了传统的select/poll
		场景：
		Channel（通道）、Buffer（缓冲区）、Selector（选择器）
		serverSocketChannel.configureBlocking(false);
 		serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
		一个IO线程可以并发处理N个句柄读取
		
	NIO2.0 AIO 异步非阻塞式IO		在Linux系统上，AIO的底层实现仍使用EPOLL		Netty整体架构是reactor模型, 而AIO是proactor模型
	server.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {

	Reactor模式
		没有Queue来做缓冲，每当一个Event输入到Service Handler之后，会立刻分发给对应的Request Handler来处理

最原始的网络编程思路就是服务器用一个while循环，不断监听端口是否有新的套接字连接，如果有，那么就调用一个处理函数(线程)处理
BIO模式

缺点在于资源要求太高，系统中创建线程是需要比较高的系统资源的，如果连接数太高，系统无法承受，而且，线程的反复创建-销毁也需要代价。
改进方法是：
采用基于事件驱动的设计，当有事件触发时，才会调用处理器进行数据处理。使用Reactor模式，对线程的数量进行控制，一个线程处理大量的事件
	
Java的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以说是Reactor模型的朴素原型。
Reactor模式，是基于Java NIO的，在他的基础上，抽象出来两个组件——Reactor和Handler两个组件：
（1）Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包含连接建立就绪、读就绪、写就绪等。
（2）Handler:将自身（handler）与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。

	
11.Sql	
Sql三种连接 集合关系  
MySQL调优 哪些索引 多键索引
	引擎区别   建表 量级分表 
	联合索引 最左前缀原则  查询优化
	Innodb ：数据完整性，并发性处理，擅长更新，删除。
	myisam：高速查询及插入。擅长插入和查询
	普通索引,index：对关键字没有要求。
	唯一索引,unique index：要求关键字不能重复。同时增加唯一约束。
	主键索引,primary key：要求关键字不能重复，也不能为NULL。同时增加主键约束。
	全文索引,fulltext key：关键字的来源不是所有字段的数据，而是从字段中提取的特别关键词
	执行计划explan f5 *具体字段 where子查询减少 优先筛选少行 EXISTS  对索引列使用OR无效 
	awr报告
			



spring如何实现循环依赖


准备

dubbo 设计框架 负载均衡 spi机制 zk选举 分布式锁 

redis aof、rdb、rewire 主从 cluster 基本类型 set zset list hash string 
expire ttl 
缓存击穿 穿透 雪崩 数据一致性，一致性hash，布隆过滤器

mysql 事务、锁、索引、b+树，主从

mq，rocketmq
	为什么用
	重复消费，顺序消息，事务消息，高可用，消息丢失，挤压场景
	
netty，零拷贝，bio，nio，aio，架构设计

算法，快速排序，堆排序，二叉树，链表反转，成环，环节点，跳楼梯
	双指针，dp，递归，手写红黑树？

网络，http,tcp,https,udp,7层网络协议

分布式事务实现，架构，
	抢红包
	，高并发下单



题0
sync底层实现，锁优化，lock对比
jvm调优详细，如何设置，好处，gc分析
redis数据结构，场景，微博场景如何设计用户关系
线程池设定 为什么
spring如何循环依赖，为什么三级缓存
优先级队列原理

项目如何设计 漏洞解决 改进 挂了？ 扩容？
高并发下单减少库存如何设计
rocketmq架构方向设计
dubbo框架原理
最近读了什么书  如何学习

项目为何这样设计，如何优化，合理更好的方式优化，数据库设计
公司做啥了，绩效如何，手写算法链表反转

jvm，sms过程，full gc做啥了
所了解的所有中间件？

为什么来，以前为什么不来，毕业到现在有什么改变





题1
b和b+树
排序算法 思想 时间复杂度 空间复杂度
两数之和三数和

tcp三次 四次 区别 为什么 
tcp udp区别
tcp粘包拆包
保持连接

并发 死锁条件 如何避免
线程状态 如何转换
linux常用指令

数据库范式 如何应用 取舍
数据库索引 底层实现mysql
mysql引擎innodb myisam区别场景
数据库事务 隔离级别
sql优化思路
外键 注意
设计数据库表 时间空间 冗余

类和对象
static final区别
synchronized 底层实现 其他锁 reentrantLock
	实现单缓冲区的生产消费模型

bio nio aio netty
接口 抽象类区别
hashmap hashtable hashset 如何去重 hash规则
concurrentHashmap 为什么安全
数字和字符串相互转换
线程状态 线程方法 join yield
线程池 如何创建 各个参数
jvm参数 xms xmx
设计模式 单例几种写法 策略设计模式  


springmvc原理 哪些设计模式
spring 依赖注入的几种方式 注解 xml配置 
spring哪些框架组件 分别做什么
	 动态代理原理
	 事务实现原理
spring bean创建过程 生命周期  父子容器
	循环依赖
		构造注入 不行
		属性方法 可以
		
springboot和springmvc区别联系
	启动流程 如何实现的自动配置



阿里一面：

自我介绍、自己做的项目和技术领域
说一下sync的底层实现，锁优化，和lock的对比
讲一下JVM参数调优详细过程
为什么这么设置？好处是什么？描述gc场景，如何去分析gc日志？
redis数据结构，使用场景，微博场景使用redis如何去设计用户关系？
线程池参数设定，为什么这么设定，作用？7大参数
spring的循环依赖如何解决？为什么要三级缓存？
优先级队列的底层原理？
阿里二面：

自我介绍一下吧
聊项目
结合你项目问你如何设计，提出漏洞，你怎么解决？如何改进，万一挂了？加一台机器有没有问题？如果我非要不出问题怎么办？
高并发下单扣库存场景如何设计
rocketMQ架构设计原理
Dubbo框架实现原理
最近读了什么书？平时怎么学习？
常用的负载均衡，该怎么用，你能说下吗？
阿里三面：

这一面主要问项目，给你的压力感比较强
结合项目问，为什么这么设计？让你去优化，你怎么优化，引导你用一个合理的更好的方式去优化，数据库的设计等
在公司做了什么事情，各个系统业务线都是做什么的，你的绩效，手写算法链表反转？
阿里四面：

JVM的主要组成部分及其作用？
JVM运行时数据区包含哪些？
JVM垃圾回收机制，何时触发MinorGC等操作
JVM的垃圾回收算法：
JVM 调优的工具？
常用的JVM调优参数？
堆栈的区别？
详细介绍一下 CMS 垃圾回收器？
怎么判断对象是否可以被回收？
新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
java类加载过程?
把你知道的中间件都说一下吧（瞬间懵了一下）
 






